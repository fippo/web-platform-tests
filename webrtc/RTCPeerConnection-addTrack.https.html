<!doctype html>
<meta charset=utf-8>
<title>RTCPeerConnection.prototype.addTrack</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="RTCPeerConnection-helper.js"></script>
<script>
function webrtc_test(testFunc, name) {
  return promise_test(t => {
    let streams = [];
    let release = () => {
      streams.forEach((stream) => {
        stream.getTracks().forEach((track) => {
          track.stop();
        });
      });
      streams = [];
    };

    if (navigator.getUserMedia) {
      let origGetUserMedia = navigator.getUserMedia.bind(navigator);
      navigator.getUserMedia = (constraints, cb, eb) => {
        origGetUserMedia(constraints, (stream) => {
          streams.push(stream);
          if (cb) {
            cb.apply(null, [stream]);
          }
        }, eb);
      };
      navigator.getUserMedia.restore = () => {
        navigator.getUserMedia = origGetUserMedia;
        release();
      };
    }

    let origMediaDevicesGetUserMedia =
        navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = (constraints) => {
      return origMediaDevicesGetUserMedia(constraints, (stream) => {
        streams.push(stream);
        return stream;
      });
    };
    navigator.mediaDevices.getUserMedia.restore = () => {
      navigator.mediaDevices.getUserMedia = origMediaDevicesGetUserMedia;
      console.log('stopping gum');
      release();
    };

    t.add_cleanup(() => {
      if (navigator.getUserMedia) {
        navigator.getUserMedia.restore();
      }
      navigator.mediaDevices.getUserMedia.restore();
    });

    let peerconnections = [];
    const origRTCPeerConnection = window.RTCPeerConnection;
    window.RTCPeerConnection = function(args) {
      const pc = new origRTCPeerConnection(args);
      peerconnections.push(pc);
      return pc;
    };
    window.RTCPeerConnection.prototype = origRTCPeerConnection.prototype;

    t.add_cleanup(() => {
      console.log('peerconnections', peerconnections, name);
      peerconnections.forEach(pc => {
        console.log('closing pc in', name);
        pc.close()
      });
      peerconnections = [];
      window.RTCPeerConnection = origRTCPeerConnection;
    });
    return testFunc(t);
  }, name);
}
</script>
<script>
  webrtc_test(async t => {
    console.log('one');
    const mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
  }, 'it releases the stream');
  webrtc_test(async t => {
    console.log('two');
    const pc = new RTCPeerConnection();
  }, 'it closes the peerconnections automagically');
  webrtc_test(async t => {
    console.log('three');
    const pc = new RTCPeerConnection();
    pc.close();
  }, 'it works even if you closed all peerconnections');
  webrtc_test(async t => {
    const pc = new RTCPeerConnection();
    const stream = await navigator.mediaDevices.getUserMedia({audio: true});
    const sender = pc.addTrack(stream.getTracks()[0]);
    assert_true(sender instanceof RTCRtpSender,
      'Expect sender to be instance of RTCRtpSender');
  }, 'addTrack with no stream');

  webrtc_test(async t => {
    const pc = new RTCPeerConnection();
    const stream = await navigator.mediaDevices.getUserMedia({audio: true});
    const sender = pc.addTrack(stream.getTracks()[0], stream);
    assert_true(sender instanceof RTCRtpSender,
      'Expect sender to be instance of RTCRtpSender');
  }, 'addTrack with stream');

  webrtc_test(async t => {
    const pc = new RTCPeerConnection();
    const stream = await navigator.mediaDevices.getUserMedia({audio: true});
    const sender = pc.addTrack(stream.getTracks()[0], stream, stream.clone());
    assert_true(sender instanceof RTCRtpSender,
      'Expect sender to be instance of RTCRtpSender');
  }, 'addTrack with two streams');
</script>
